<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <title>WebRTC ‚Äì Web Client ‚Üî STUN ‚Üî Python</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 960px;
      margin: 2rem auto;
      padding: 0 1rem;
      background: #f5f7fb;
      color: #222;
    }
    .time-value {
      margin-left: 2px;
      font-size: 0.65rem;
      color: #555;
    }
    h1 {
      margin-bottom: 0.25rem;
    }
    h2 {
      margin-top: 2rem;
    }

    /* --- BOVENSTE BLOKKEN ------------------------------------------------- */

    .diagram {
      display: flex;
      justify-content: space-between;
      gap: 1rem;
      align-items: flex-start;
      margin: 1.5rem 0;
    }

    .node {
      background: #ffffff;
      border-radius: 10px;
      padding: 0.75rem;
      text-align: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.06);
      font-weight: 600;
      position: relative;
      flex: 0 0 18%;
    }

    .node span {
      display: block;
      font-size: 0.8rem;
      font-weight: 400;
      color: #666;
      margin-top: 0.25rem;
    }

    .lane-label {
      text-align: center;
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.25rem;
    }

    /* --- LIJNEN & LIFELINES ONDER DE BLOKKEN ------------------------------ */

    .arrows {
      position: relative;
      margin-top: 1rem;
      height: 450px; /* ruimte voor alle pijlen inclusief TURN */
      font-size: 0.8rem;
    }

    /* verticale lifelines */
    .lifeline {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 0;
    }

    .lifeline-line {
      position: absolute;
      top: 0;
      bottom: 0;
      border-left: 2px dotted #cbd5f5;
    }

    .time-axis-label {
      position: absolute;
      top: -1.6rem;
      left: -0.4rem;
      font-size: 0.7rem;
      color: #666;
      font-weight: 600;
    }

    .time-tick {
      position: absolute;
      left: -0.8rem;
      font-size: 0.7rem;
      color: #999;
    }

    /* lifeline posities (centra van de vijf kolommen) */
    .lifeline-web       { left: 9%; }
    .lifeline-signaling { left: 28%; }
    .lifeline-stun      { left: 47%; }
    .lifeline-turn      { left: 66%; }
    .lifeline-python    { left: 85%; }

    /* horizontale pijlen */
    .arrow {
      position: absolute;
      display: flex;
      align-items: center;
      opacity: 0.25;
      transition: opacity 0.25s ease-out, transform 0.25s ease-out;
      font-family: monospace;
    }

    .arrow-line {
      border-top: 2px dashed #555;
      position: relative;
      width: 100%;
    }

    .arrow-line::after {
      content: "‚ñ∂";
      position: absolute;
      right: -0.25rem;
      top: -0.9rem;
      font-size: 1rem;
    }

    .arrow.reverse .arrow-line::after {
      content: "‚óÄ";
      right: auto;
      left: -0.25rem;
    }

    .arrow-label {
      position: absolute;
      top: -1.2rem;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
    }

    /* Animeren bij activatie */
    .arrow.active {
      opacity: 1;
      transform: translateY(-2px);
      animation: pulse 0.9s ease-out 1;
    }

    @keyframes pulse {
      0%   { transform: translateY(-2px) scale(1.0); }
      40%  { transform: translateY(-3px) scale(1.04); }
      100% { transform: translateY(-2px) scale(1.0); }
    }

    /* Posities tussen de kolommen:
       WEB ~9%, SIGNALING ~28%, STUN ~47%, TURN ~66%, PYTHON ~85%
    */

    /* 1. WEB ‚Üí STUN (ICE gathering) */
    #arrow-web-stun {
      top: 15px;
      left: 9%;
      width: 38%;      /* 47% - 9% */
    }

    /* 2. STUN ‚Üí WEB (candidates) */
    #arrow-stun-web {
      top: 45px;
      left: 9%;
      width: 38%;
    }

    /* 3. WEB ‚Üí TURN (request relay) */
    #arrow-web-turn {
      top: 75px;
      left: 9%;
      width: 57%;      /* 66% - 9% */
    }

    /* 4. TURN ‚Üí WEB (relay allocated) */
    #arrow-turn-web {
      top: 105px;
      left: 9%;
      width: 57%;
    }

    /* 5. WEB ‚Üí SIGNALING (offer JSON) */
    #arrow-web-signaling {
      top: 135px;
      left: 9%;
      width: 19%;      /* 28% - 9% */
    }

    /* 6. SIGNALING ‚Üí PYTHON (forward offer) */
    #arrow-signaling-python {
      top: 165px;
      left: 28%;
      width: 57%;      /* 85% - 28% */
    }

    /* 7. PYTHON ‚Üí STUN (ICE gathering) */
    #arrow-python-stun {
      top: 195px;
      left: 47%;
      width: 38%;      /* 85% - 47% */
    }

    /* 8. STUN ‚Üí PYTHON (candidates) */
    #arrow-stun-python {
      top: 225px;
      left: 47%;
      width: 38%;
    }

    /* 9. PYTHON ‚Üí TURN (request relay) */
    #arrow-python-turn {
      top: 255px;
      left: 66%;
      width: 19%;      /* 85% - 66% */
    }

    /* 10. TURN ‚Üí PYTHON (relay allocated) */
    #arrow-turn-python {
      top: 285px;
      left: 66%;
      width: 19%;
    }

    /* 11. PYTHON ‚Üí SIGNALING (answer JSON) */
    #arrow-python-signaling {
      top: 315px;
      left: 28%;
      width: 57%;
    }

    /* 12. SIGNALING ‚Üí WEB (forward answer) */
    #arrow-signaling-web {
      top: 345px;
      left: 9%;
      width: 19%;
    }

    /* 13. WEB ‚Üî PYTHON (direct P2P if possible) */
    #arrow-ice-connect {
      top: 375px;
      left: 9%;
      width: 76%;      /* 85% - 9% */
    }

    /* 14. WEB ‚Üî TURN ‚Üî PYTHON (relay fallback) */
    #arrow-relay-flow {
      top: 405px;
      left: 9%;
      width: 76%;
    }

    .arrow.bidirectional .arrow-line {
      border-top: 2px solid #10b981;
    }

    .arrow.bidirectional .arrow-line::after {
      content: "‚Üî";
      font-size: 1.2rem;
      right: 50%;
      transform: translateX(50%);
    }

    /* --- CONTROLS & VIDEO ------------------------------------------------- */

    #controls {
      margin: 1rem 0;
    }

    button {
      padding: 0.5rem 1rem;
      font-size: 0.95rem;
      border-radius: 999px;
      border: none;
      background: #2563eb;
      color: white;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(37,99,235,0.35);
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    #video-row {
      margin: 1rem 0;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
    }

    video {
      width: 260px;
      height: 190px;
      background: #000;
      border-radius: 10px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.25);
      margin-right: 1rem;
    }

    /* --- LOG -------------------------------------------------------------- */

    #log {
      border-radius: 8px;
      padding: 0.75rem;
      height: 220px;
      overflow-y: auto;
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      background: #0b1020;
      color: #d6e4ff;
      font-size: 0.8rem;
    }

    .log-line {
      opacity: 0;
      transform: translateY(4px);
      animation: log-enter 0.18s ease-out forwards;
    }

    @keyframes log-enter {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .log-tag {
      display: inline-block;
      min-width: 110px;
      font-weight: 600;
    }

    .tag-web { color: #38bdf8; }
    .tag-signaling { color: #fb923c; }
    .tag-stun { color: #a855f7; }
    .tag-python { color: #4ade80; }
    .tag-join { color: #facc15; }

    /* NAT/Router visualization */
    .network-layer {
      display: flex;
      justify-content: space-between;
      margin: 1.5rem 0;
      padding: 1rem;
      background: linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%);
      border-radius: 8px;
      border: 2px dashed #94a3b8;
    }

    .network-zone {
      flex: 1;
      margin: 0 0.5rem;
      padding: 1rem;
      background: white;
      border-radius: 8px;
      border: 2px solid #cbd5e1;
      position: relative;
    }

    .network-zone.internet {
      flex: 2;
      background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
      border-color: #3b82f6;
    }

    .zone-label {
      font-weight: 600;
      font-size: 0.75rem;
      color: #64748b;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .nat-router {
      background: #fef3c7;
      border: 2px solid #f59e0b;
      border-radius: 6px;
      padding: 0.5rem;
      margin: 0.5rem 0;
      font-size: 0.75rem;
      text-align: center;
      font-weight: 600;
    }

    .nat-type {
      font-size: 0.65rem;
      color: #dc2626;
      font-weight: 400;
      margin-top: 0.25rem;
    }

    .network-ip {
      font-size: 0.7rem;
      color: #475569;
      font-family: monospace;
      margin-top: 0.25rem;
    }

    .firewall-icon {
      display: inline-block;
      color: #dc2626;
      font-size: 1rem;
      margin-right: 0.25rem;
    }

    /* Mobiel: blokken onder elkaar, pijlen en lifelines weglaten */
    @media (max-width: 800px) {
      .diagram {
        flex-direction: column;
      }
      .arrows {
        display: none;
      }
      .network-layer {
        flex-direction: column;
      }
      video {
        margin-bottom: 0.75rem;
      }
    }
  </style>
</head>
<body>
<h1>WebRTC: Web Client ‚Üî Signaling ‚Üî STUN ‚Üî TURN ‚Üî Python</h1>
<p>
  Druk op <strong>Start WebRTC flow</strong> en kijk hoe diagram, lifelines en log
  exact de stappen volgen. De <strong>SIGNALING SERVER</strong> (Python HTTP server) verzendt
  SDP offers en answers. <strong>STUN</strong> ontdekt publieke IP-adressen voor NAT traversal.
  <strong>TURN</strong> biedt media relay als fallback wanneer directe P2P connectie niet mogelijk is.
</p>
<p style="background: #fff3cd; padding: 0.75rem; border-radius: 6px; font-size: 0.9rem; border-left: 4px solid #ffc107;">
  <strong>‚ö†Ô∏è SSH Tunnel Note:</strong> If running through SSH tunnel, direct P2P connection may fail. 
  Both peers need to be on the same network or use a TURN relay server. The demo includes TURN servers 
  but they may not work reliably with aiortc.
</p>

<h2 style="margin-top:2rem;">Network Topology</h2>
<div class="network-layer">
  <div class="network-zone">
    <div class="zone-label">Local Network (Browser)</div>
    <div style="padding:0.5rem; text-align:center;">
      <div style="font-size:0.85rem; font-weight:600;">üñ•Ô∏è WEB CLIENT</div>
      <div class="network-ip" id="browser-local-ip">(detecting...)</div>
    </div>
    <div class="nat-router" id="browser-nat">
      <div><span class="firewall-icon" id="browser-nat-icon">üõ°Ô∏è</span>NAT Router (Browser Side)</div>
      <div class="nat-type" id="browser-nat-type">Detecting NAT type...</div>
      <div class="network-ip" id="browser-public-ip">Public: (detecting...)</div>
    </div>
  </div>

  <div class="network-zone internet">
    <div class="zone-label">Public Internet</div>
    <div style="display:flex; justify-content:space-around; padding:0.5rem;">
      <div style="text-align:center;">
        <div style="font-size:0.85rem; font-weight:600;">üåê SIGNALING</div>
        <div class="network-ip">HTTP Server</div>
      </div>
      <div style="text-align:center;">
        <div style="font-size:0.85rem; font-weight:600;">üëÅÔ∏è STUN</div>
        <div class="network-ip">Discovers IPs</div>
      </div>
      <div style="text-align:center;">
        <div style="font-size:0.85rem; font-weight:600;">üîÑ TURN</div>
        <div class="network-ip">Relay Server</div>
      </div>
    </div>
    <div style="text-align:center; font-size:0.7rem; color:#1e40af; margin-top:0.5rem;">
      ‚úì No firewall restrictions - publicly accessible
    </div>
  </div>

  <div class="network-zone">
    <div class="zone-label">Remote Network (Python)</div>
    <div style="padding:0.5rem; text-align:center;">
      <div style="font-size:0.85rem; font-weight:600;">üêç PYTHON WEBRTC</div>
      <div class="network-ip" id="python-local-ip">192.168.86.25</div>
    </div>
    <div class="nat-router" id="python-nat">
      <div><span class="firewall-icon" id="python-nat-icon">üõ°Ô∏è</span>NAT Router (Python Side)</div>
      <div class="nat-type" id="python-nat-type">Detecting NAT type...</div>
      <div class="network-ip" id="python-public-ip">Public: (detecting...)</div>
    </div>
  </div>
</div>

<div style="background:#fee; padding:0.75rem; border-radius:6px; margin:1rem 0; border-left:4px solid #dc2626; font-size:0.85rem;">
  <strong>üö´ Why Direct P2P Fails:</strong>
  <ul style="margin:0.5rem 0; padding-left:1.5rem;">
    <li><strong>Different networks:</strong> 192.168.90.x ‚â† 192.168.86.x (can't route directly)</li>
    <li><strong>Symmetric NAT:</strong> Both routers block inbound connections that weren't initiated from inside</li>
    <li><strong>SSH tunnel:</strong> Only helps signaling (HTTP), not media (UDP)</li>
    <li><strong>No TURN relay:</strong> Need relay server to forward traffic between isolated networks</li>
  </ul>
</div>

<h2 style="margin-top:2rem;">WebRTC Signaling Sequence</h2>
<section class="diagram">
  <div>
    <div id="node-web" class="node">
      WEB CLIENT
      <span>Browser (JavaScript)</span>
    </div>
    <div class="lane-label">SDP + ICE offer</div>
  </div>
  <div>
    <div id="node-signaling" class="node">
      SIGNALING SERVER
      <span>Python HTTP (aiohttp)</span>
    </div>
    <div class="lane-label">Offer/Answer exchange</div>
  </div>
  <div>
    <div id="node-stun" class="node">
      STUN SERVER
      <span>stun.l.google.com</span>
    </div>
    <div class="lane-label">Public IP discovery</div>
  </div>
  <div>
    <div id="node-turn" class="node">
      TURN SERVER
      <span>openrelay.metered.ca</span>
    </div>
    <div class="lane-label">Media relay (fallback)</div>
  </div>
  <div>
    <div id="node-python" class="node">
      PYTHON WEBRTC
      <span>aiortc RTCPeerConnection</span>
    </div>
    <div class="lane-label">SDP answer + ICE</div>
  </div>
</section>

<section class="arrows">
   <!-- Lifelines -->
  <div class="lifeline lifeline-web">
    <div class="lifeline-line"></div>
    <div class="time-axis-label">tijd</div>
    <!-- ticks op dezelfde hoogte als de pijlen -->
    <div class="time-tick" style="top: 15px;">1<span id="time1" class="time-value"></span></div>
    <div class="time-tick" style="top: 45px;">2<span id="time2" class="time-value"></span></div>
    <div class="time-tick" style="top: 75px;">3<span id="time3" class="time-value"></span></div>
    <div class="time-tick" style="top: 105px;">4<span id="time4" class="time-value"></span></div>
    <div class="time-tick" style="top: 135px;">5<span id="time5" class="time-value"></span></div>
  </div>
  <div class="lifeline lifeline-signaling">
    <div class="lifeline-line"></div>
  </div>
  <div class="lifeline lifeline-stun">
    <div class="lifeline-line"></div>
  </div>
  <div class="lifeline lifeline-turn">
    <div class="lifeline-line"></div>
  </div>
  <div class="lifeline lifeline-python">
    <div class="lifeline-line"></div>
  </div>

  <!-- 1. WEB ‚Üí STUN (ICE gathering) -->
  <div class="arrow" id="arrow-web-stun">
    <div class="arrow-line"></div>
    <div class="arrow-label">WEB ‚Üí STUN (discover IP)</div>
  </div>

  <!-- 2. STUN ‚Üí WEB (candidates) -->
  <div class="arrow reverse" id="arrow-stun-web">
    <div class="arrow-line"></div>
    <div class="arrow-label">STUN ‚Üí WEB (public IP)</div>
  </div>

  <!-- 3. WEB ‚Üí TURN (request relay) -->
  <div class="arrow" id="arrow-web-turn">
    <div class="arrow-line"></div>
    <div class="arrow-label">WEB ‚Üí TURN (request relay)</div>
  </div>

  <!-- 4. TURN ‚Üí WEB (relay allocated) -->
  <div class="arrow reverse" id="arrow-turn-web">
    <div class="arrow-line"></div>
    <div class="arrow-label">TURN ‚Üí WEB (relay candidate)</div>
  </div>

  <!-- 5. WEB ‚Üí SIGNALING (offer JSON) -->
  <div class="arrow" id="arrow-web-signaling">
    <div class="arrow-line"></div>
    <div class="arrow-label">WEB ‚Üí SIGNALING (offer)</div>
  </div>

  <!-- 6. SIGNALING ‚Üí PYTHON (forward offer) -->
  <div class="arrow" id="arrow-signaling-python">
    <div class="arrow-line"></div>
    <div class="arrow-label">SIGNALING ‚Üí PYTHON (offer)</div>
  </div>

  <!-- 7. PYTHON ‚Üí STUN (ICE gathering) -->
  <div class="arrow reverse" id="arrow-python-stun">
    <div class="arrow-line"></div>
    <div class="arrow-label">PYTHON ‚Üí STUN (discover IP)</div>
  </div>

  <!-- 8. STUN ‚Üí PYTHON (candidates) -->
  <div class="arrow" id="arrow-stun-python">
    <div class="arrow-line"></div>
    <div class="arrow-label">STUN ‚Üí PYTHON (public IP)</div>
  </div>

  <!-- 9. PYTHON ‚Üí TURN (request relay) -->
  <div class="arrow reverse" id="arrow-python-turn">
    <div class="arrow-line"></div>
    <div class="arrow-label">PYTHON ‚Üí TURN (request relay)</div>
  </div>

  <!-- 10. TURN ‚Üí PYTHON (relay allocated) -->
  <div class="arrow" id="arrow-turn-python">
    <div class="arrow-line"></div>
    <div class="arrow-label">TURN ‚Üí PYTHON (relay candidate)</div>
  </div>

  <!-- 11. PYTHON ‚Üí SIGNALING (answer JSON) -->
  <div class="arrow reverse" id="arrow-python-signaling">
    <div class="arrow-line"></div>
    <div class="arrow-label">PYTHON ‚Üí SIGNALING (answer)</div>
  </div>

  <!-- 12. SIGNALING ‚Üí WEB (forward answer) -->
  <div class="arrow reverse" id="arrow-signaling-web">
    <div class="arrow-line"></div>
    <div class="arrow-label">SIGNALING ‚Üí WEB (answer)</div>
  </div>

  <!-- 13. WEB ‚Üî PYTHON (direct P2P - preferred) -->
  <div class="arrow bidirectional" id="arrow-ice-connect" style="border-color:#10b981;">
    <div class="arrow-line"></div>
    <div class="arrow-label">WEB ‚Üî PYTHON (direct P2P) ‚úì</div>
  </div>

  <!-- 14. WEB ‚Üî TURN ‚Üî PYTHON (relay fallback) -->
  <div class="arrow bidirectional" id="arrow-relay-flow" style="opacity:0.4;">
    <div class="arrow-line" style="border-top:2px dashed #f59e0b;"></div>
    <div class="arrow-label" style="color:#f59e0b;">WEB ‚Üî TURN ‚Üî PYTHON (relay fallback)</div>
  </div>
</section>

<section id="controls">
  <button id="startBtn">Start WebRTC flow</button>
</section>

<section id="video-row">
  <div>
    <div style="font-size:0.8rem; margin-bottom:0.25rem;">Local stream (WEB CLIENT)</div>
    <video id="localVideo" autoplay playsinline muted></video>
  </div>
  <div>
    <div style="font-size:0.8rem; margin-bottom:0.25rem;">
      Remote stream (from PYTHON)
      <span id="latencyDisplay" style="color: #10b981; font-weight: 600; margin-left: 8px;"></span>
    </div>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>
</section>

<h2>ICE Candidate Analysis</h2>
<div id="ice-analysis" style="display:none; background:#f8f9fa; padding:1rem; border-radius:8px; margin:1rem 0; border-left:4px solid #6c757d;">
  <div style="display:grid; grid-template-columns: 1fr 1fr; gap:1rem;">
    <div>
      <h3 style="margin-top:0; color:#38bdf8; font-size:1rem;">WEB CLIENT Candidates</h3>
      <div id="local-candidates" style="font-family:monospace; font-size:0.75rem;"></div>
    </div>
    <div>
      <h3 style="margin-top:0; color:#4ade80; font-size:1rem;">PYTHON Candidates</h3>
      <div id="remote-candidates" style="font-family:monospace; font-size:0.75rem;"></div>
    </div>
  </div>
  <div id="match-analysis" style="margin-top:1rem; padding:1rem; background:white; border-radius:6px;"></div>
</div>

<h2>Timeline log</h2>
<div id="log"></div>

<script>
  const logEl = document.getElementById('log');
  const startBtn = document.getElementById('startBtn');
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const latencyDisplay = document.getElementById('latencyDisplay');

  const arrows = {
    'web-stun': document.getElementById('arrow-web-stun'),
    'stun-web': document.getElementById('arrow-stun-web'),
    'web-turn': document.getElementById('arrow-web-turn'),
    'turn-web': document.getElementById('arrow-turn-web'),
    'web-signaling': document.getElementById('arrow-web-signaling'),
    'signaling-python': document.getElementById('arrow-signaling-python'),
    'python-stun': document.getElementById('arrow-python-stun'),
    'stun-python': document.getElementById('arrow-stun-python'),
    'python-turn': document.getElementById('arrow-python-turn'),
    'turn-python': document.getElementById('arrow-turn-python'),
    'python-signaling': document.getElementById('arrow-python-signaling'),
    'signaling-web': document.getElementById('arrow-signaling-web'),
    'ice-connect': document.getElementById('arrow-ice-connect'),
    'relay-flow': document.getElementById('arrow-relay-flow'),
  };

  // Time measurement
  let startTime = null;
  const timeElements = {
    time1: document.getElementById('time1'),
    time2: document.getElementById('time2'),
    time3: document.getElementById('time3'),
    time4: document.getElementById('time4'),
    time5: document.getElementById('time5'),
  };

  function setTimeValue(timeId) {
    if (!startTime) {
      startTime = performance.now();
    }
    const elapsed = performance.now() - startTime;
    const el = timeElements[timeId];
    if (el) {
      el.textContent = `(${elapsed.toFixed(0)}ms)`;
    }
    return elapsed;
  }

  function activateArrow(name, timing) {
    const el = arrows[name];
    if (!el) return;
    el.classList.remove('active');
    // reflow for opnieuw starten animatie
    void el.offsetWidth;
    el.classList.add('active');
    
    // Add timing number with timestamp to arrow label if provided
    if (timing !== undefined) {
      const label = el.querySelector('.arrow-label');
      if (label) {
        const originalText = label.textContent;
        // Check if timing is already added
        if (!originalText.match(/^\d+\s*\(/)) {
          const elapsed = startTime ? Math.round(performance.now() - startTime) : 0;
          label.textContent = timing + ' (' + elapsed + 'ms) ' + originalText;
        }
      }
    }
  }

  function addLog(tag, message, tagClass) {
    const line = document.createElement('div');
    line.className = 'log-line';
    const span = document.createElement('span');
    span.className = 'log-tag ' + (tagClass || '');
    span.textContent = '[' + tag + '] ';
    line.appendChild(span);
    
    // Add timestamp
    if (startTime) {
      const elapsed = performance.now() - startTime;
      const timeSpan = document.createElement('span');
      timeSpan.className = 'time-value';
      timeSpan.textContent = `[${elapsed.toFixed(0)}ms] `;
      line.appendChild(timeSpan);
    }
    
    line.appendChild(document.createTextNode(message));
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ICE Candidate Analysis
  const localCandidates = [];
  const remoteCandidates = [];
  let pc = null; // Global reference to peer connection

  function parseCandidateInfo(candidateStr) {
    const parts = candidateStr.split(' ');
    const info = {
      ip: parts[4] || 'unknown',
      port: parts[5] || 'unknown',
      type: parts[7] || 'unknown',
      protocol: parts[2] || 'unknown',
      full: candidateStr
    };
    return info;
  }

  async function analyzeNetworkMatch() {
    const analysisEl = document.getElementById('ice-analysis');
    const matchAnalysisEl = document.getElementById('match-analysis');
    analysisEl.style.display = 'block';

    // Display local candidates
    const localEl = document.getElementById('local-candidates');
    localEl.innerHTML = '<div style="margin-bottom:0.5rem; font-weight:600;">Networks detected:</div>';
    const localNetworks = new Set();
    const localIPs = new Set();
    localCandidates.forEach((cand, i) => {
      const info = parseCandidateInfo(cand);
      localIPs.add(info.ip);
      // Only add network prefix for IPv4
      if (info.ip.includes('.') && !info.ip.includes(':')) {
        const network = info.ip.split('.').slice(0, 3).join('.');
        localNetworks.add(network);
      }
      const color = info.type === 'host' ? '#3b82f6' : info.type === 'srflx' ? '#10b981' : '#f59e0b';
      localEl.innerHTML += `<div style="color:${color}; margin:0.25rem 0;">${i+1}. ${info.type}: ${info.ip}:${info.port} (${info.protocol})</div>`;
    });

    // Display remote candidates
    const remoteEl = document.getElementById('remote-candidates');
    remoteEl.innerHTML = '<div style="margin-bottom:0.5rem; font-weight:600;">Networks detected:</div>';
    const remoteNetworks = new Set();
    const remoteIPs = new Set();
    remoteCandidates.forEach((cand, i) => {
      const info = parseCandidateInfo(cand);
      remoteIPs.add(info.ip);
      // Only add network prefix for IPv4
      if (info.ip.includes('.') && !info.ip.includes(':')) {
        const network = info.ip.split('.').slice(0, 3).join('.');
        remoteNetworks.add(network);
      }
      const color = info.type === 'host' ? '#3b82f6' : info.type === 'srflx' ? '#10b981' : '#f59e0b';
      remoteEl.innerHTML += `<div style="color:${color}; margin:0.25rem 0;">${i+1}. ${info.type}: ${info.ip}:${info.port} (${info.protocol})</div>`;
    });

    // Check actual connection state and selected candidate pair
    const isConnected = pc && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed');
    let selectedPairInfo = null;
    
    if (isConnected && pc) {
      try {
        const stats = await pc.getStats();
        let selectedPair = null;
        let localCand = null;
        let remoteCand = null;
        
        // Find the selected (nominated) candidate pair
        stats.forEach(report => {
          if (report.type === 'candidate-pair' && (report.state === 'succeeded' || report.nominated)) {
            selectedPair = report;
          }
        });
        
        // Get the actual candidates used
        if (selectedPair) {
          stats.forEach(report => {
            if (report.type === 'local-candidate' && report.id === selectedPair.localCandidateId) {
              localCand = report;
            }
            if (report.type === 'remote-candidate' && report.id === selectedPair.remoteCandidateId) {
              remoteCand = report;
            }
          });
          
          selectedPairInfo = {
            local: localCand,
            remote: remoteCand,
            pair: selectedPair
          };
        }
      } catch (e) {
        console.error('Error getting stats:', e);
      }
    }
    
    // Analyze compatibility
    const localNets = Array.from(localNetworks);
    const remoteNets = Array.from(remoteNetworks);
    const hasOverlap = localNets.some(ln => remoteNets.includes(ln));
    const hasRelay = localCandidates.some(c => c.includes('relay')) || remoteCandidates.some(c => c.includes('relay'));

    let diagnosis = '';
    
    // If already connected, show the actual selected candidate pair
    if (isConnected && selectedPairInfo) {
      const local = selectedPairInfo.local;
      const remote = selectedPairInfo.remote;
      
      const localType = local.candidateType || 'unknown';
      const remoteType = remote.candidateType || 'unknown';
      const localIP = local.address || local.ip || 'unknown';
      const remoteIP = remote.address || remote.ip || 'unknown';
      
      const typeColor = localType === 'host' ? '#3b82f6' : localType === 'srflx' ? '#10b981' : '#f59e0b';
      
      diagnosis = `<div style="color:#10b981; font-weight:600;">‚úì Connection Established!</div>
        <div style="margin-top:0.5rem; padding:0.75rem; background:#d1fae5; border-radius:4px;">
          <strong>Selected Candidate Pair:</strong><br>
          <div style="margin-top:0.5rem;">
            ‚Ä¢ Local: <span style="color:${typeColor}; font-weight:600;">${localType}</span> ${localIP}:${local.port || '?'}<br>
            ‚Ä¢ Remote: <span style="color:${typeColor}; font-weight:600;">${remoteType}</span> ${remoteIP}:${remote.port || '?'}
          </div>
          <div style="margin-top:0.5rem; padding-top:0.5rem; border-top:1px solid #86efac;">
            ${localType === 'host' && remoteType === 'host' ? 
              '<strong>‚úì Direct connection on same network</strong> - No NAT traversal needed!' :
              localType === 'relay' || remoteType === 'relay' ?
              '<strong>‚Üî Using TURN relay</strong> - NATs blocked direct connection' :
              '<strong>‚úì P2P through NAT</strong> - STUN-assisted connection succeeded'}
          </div>
        </div>`;
    } else if (isConnected) {
      // Connected but no detailed stats
      const commonNets = localNets.filter(ln => remoteNets.includes(ln));
      if (commonNets.length > 0) {
        diagnosis = `<div style="color:#10b981; font-weight:600;">‚úì Connection Established - Network Overlap</div>
          <div style="margin-top:0.5rem;">Common networks: ${commonNets.join(', ')}.x</div>
          <div style="margin-top:0.5rem; padding:0.75rem; background:#d1fae5; border-radius:4px;">
            <strong>‚úì Direct P2P connection succeeded!</strong> Both peers can reach each other on shared network.
          </div>`;
      } else {
        diagnosis = `<div style="color:#10b981; font-weight:600;">‚úì Connection Established</div>
          <div style="margin-top:0.5rem;">P2P connection succeeded through NAT traversal.</div>`;
      }
    } else if (hasOverlap) {
      diagnosis = `<div style="color:#10b981; font-weight:600;">‚úì Network Overlap Found</div>
        <div style="margin-top:0.5rem;">Common networks: ${localNets.filter(ln => remoteNets.includes(ln)).join(', ')}.x</div>
        <div style="margin-top:0.5rem; padding:0.75rem; background:#d1fae5; border-radius:4px;">
          <strong>‚úì Direct P2P possible!</strong> Both peers can reach each other on shared network.
          NAT is likely <strong>Full Cone or Port-Restricted</strong> (allows P2P connections).
        </div>`;
    } else if (hasRelay) {
      diagnosis = `<div style="color:#3b82f6; font-weight:600;">‚Üî TURN Relay Available</div>
        <div style="margin-top:0.5rem;">No common networks, but relay candidates found. Connection will use TURN relay.</div>`;
    } else {
      diagnosis = `<div style="color:#dc2626; font-weight:600;">‚úó No Compatible Path Found</div>
        <div style="margin-top:0.5rem; padding:0.75rem; background:#fee; border-radius:4px;">
          <strong>Problem:</strong> Different networks detected:<br>
          ‚Ä¢ WEB CLIENT: ${localNets.join(', ')}<br>
          ‚Ä¢ PYTHON: ${remoteNets.join(', ')}<br><br>
          <strong>Why this fails:</strong><br>
          ‚Ä¢ Peers are on different networks (likely SSH tunnel scenario)<br>
          ‚Ä¢ No relay (TURN) candidates available<br>
          ‚Ä¢ Direct peer-to-peer connection impossible<br><br>
          <strong>Solutions:</strong><br>
          1. Run both on same network/machine<br>
          2. Configure working TURN server for relay<br>
          3. Set up proper network routing between ${localNets[0]}.x and ${remoteNets[0]}.x
        </div>`;
    }

    matchAnalysisEl.innerHTML = diagnosis;
  }

  startBtn.onclick = async () => {
    startBtn.disabled = true;
    logEl.textContent = '';
    Object.values(arrows).forEach(a => a.classList.remove('active'));
    document.getElementById('ice-analysis').style.display = 'none';
    localCandidates.length = 0;
    remoteCandidates.length = 0;
    
    // Reset time measurements
    startTime = null;
    Object.values(timeElements).forEach(el => el.textContent = '');
    
    try {
      await startWebRTCFlow();
    } catch (e) {
      console.error(e);
      addLog('ERROR', String(e), 'tag-join');
      startBtn.disabled = false;
    }
  };

  async function startWebRTCFlow() {
    // 1. Local media
    addLog('WEB CLIENT', 'Requesting camera/mic‚Ä¶', 'tag-web');
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    localVideo.srcObject = stream;

    // 2. PeerConnection met STUN/TURN
    addLog('WEB CLIENT', 'Creating RTCPeerConnection with STUN/TURN servers‚Ä¶', 'tag-web');
    pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        // Free TURN servers for testing (relay for SSH tunnel scenarios)
        { 
          urls: [
            'turn:openrelay.metered.ca:80',
            'turn:openrelay.metered.ca:443',
            'turns:openrelay.metered.ca:443'
          ],
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:numb.viagenie.ca',
          username: 'webrtc@live.com',
          credential: 'muazkh'
        }
      ],
      iceCandidatePoolSize: 10
    });

    stream.getTracks().forEach(track => pc.addTrack(track, stream));

    pc.addEventListener('track', event => {
      addLog('WEB CLIENT', 'Received remote track from PYTHON WEBRTC.', 'tag-web');
      if (remoteVideo.srcObject !== event.streams[0]) {
        remoteVideo.srcObject = event.streams[0];
      }
    });

    pc.addEventListener('icegatheringstatechange', () => {
      addLog('WEB CLIENT', 'ICE gathering state: ' + pc.iceGatheringState, 'tag-web');
      if (pc.iceGatheringState === 'gathering') {
        setTimeValue('time1');
        addLog('WEB ‚Üí STUN', 'Browser starts contacting STUN for ICE candidates. (tijd 1)', 'tag-stun');
        activateArrow('web-stun', '1');
      }
      if (pc.iceGatheringState === 'complete') {
        setTimeValue('time2');
        addLog('STUN ‚Üí WEB', 'ICE gathering complete; candidates now known in the browser. (tijd 2)', 'tag-stun');
        activateArrow('stun-web', '2');
      }
    });

    let webCandidateCount = 0;
    let hasTurnCandidate = false;
    pc.addEventListener('icecandidate', event => {
      if (event.candidate) {
        webCandidateCount++;
        localCandidates.push(event.candidate.candidate);
        addLog('WEB CLIENT', 'New ICE candidate #' + webCandidateCount + ': ' + event.candidate.candidate.substring(0, 50) + '...', 'tag-web');
        
        // Update network topology with actual IPs
        const info = parseCandidateInfo(event.candidate.candidate);
        if (info.type === 'host') {
          document.getElementById('browser-local-ip').textContent = info.ip;
        } else if (info.type === 'srflx') {
          document.getElementById('browser-public-ip').textContent = 'Public: ' + info.ip;
        }
        
        // Check if this is a relay (TURN) candidate
        if (event.candidate.candidate.includes('relay') && !hasTurnCandidate) {
          hasTurnCandidate = true;
          setTimeValue('time3');
          addLog('WEB ‚Üí TURN', 'Requesting relay allocation from TURN server. (tijd 3)', 'tag-stun');
          activateArrow('web-turn', '3');
          setTimeout(() => {
            setTimeValue('time4');
            addLog('TURN ‚Üí WEB', 'TURN relay candidate allocated. (tijd 4)', 'tag-stun');
            activateArrow('turn-web', '4');
          }, 100);
        }
      } else {
        // null candidate means gathering complete
        addLog('WEB CLIENT', 'ICE gathering complete (sent ' + webCandidateCount + ' candidates)', 'tag-web');
        if (!hasTurnCandidate) {
          addLog('WEB CLIENT', '‚ö†Ô∏è No TURN relay candidates - direct connection required', 'tag-web');
        }
      }
    });

    pc.addEventListener('iceconnectionstatechange', async () => {
      addLog('ICE CONNECTION', 'ICE state: ' + pc.iceConnectionState, 'tag-join');
      if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
        // Check which candidate pair was selected
        const stats = await pc.getStats();
        let selectedPair = null;
        stats.forEach(report => {
          if (report.type === 'candidate-pair' && report.state === 'succeeded') {
            selectedPair = report;
          }
        });
        
        if (selectedPair) {
          // Check if using relay
          let localCand = null, remoteCand = null;
          stats.forEach(report => {
            if (report.type === 'local-candidate' && report.id === selectedPair.localCandidateId) {
              localCand = report;
            }
            if (report.type === 'remote-candidate' && report.id === selectedPair.remoteCandidateId) {
              remoteCand = report;
            }
          });
          
          const usingRelay = (localCand && localCand.candidateType === 'relay') || 
                            (remoteCand && remoteCand.candidateType === 'relay');
          
          if (usingRelay) {
            addLog('WEB ‚Üî TURN ‚Üî PYTHON', '‚úì Connection via TURN relay! (fallback path)', 'tag-join');
            activateArrow('relay-flow');
            arrows['relay-flow'].style.opacity = '1';
            arrows['ice-connect'].style.opacity = '0.3';
            
            // Update analysis for relay connection
            await analyzeNetworkMatch();
          } else {
            addLog('WEB ‚Üî PYTHON', '‚úì Direct P2P connection! (optimal path)', 'tag-join');
            activateArrow('ice-connect');
            arrows['ice-connect'].style.opacity = '1';
            arrows['relay-flow'].style.opacity = '0.3';
            
            // Update NAT status based on connection success
            const browserNatType = document.getElementById('browser-nat-type');
            const pythonNatType = document.getElementById('python-nat-type');
            const browserNatIcon = document.getElementById('browser-nat-icon');
            const pythonNatIcon = document.getElementById('python-nat-icon');
            
            // Check if we're on same network (host candidates worked)
            const usedHostCandidates = localCand && localCand.candidateType === 'host';
            
            if (usedHostCandidates) {
              // Direct connection on same network - no NAT traversal needed
              if (browserNatType) {
                browserNatType.textContent = '‚úì Same network - Direct connection (no NAT traversal)';
                browserNatType.style.color = '#10b981';
              }
              if (pythonNatType) {
                pythonNatType.textContent = '‚úì Same network - Direct connection (no NAT traversal)';
                pythonNatType.style.color = '#10b981';
              }
              if (browserNatIcon) browserNatIcon.textContent = '‚úÖ';
              if (pythonNatIcon) pythonNatIcon.textContent = '‚úÖ';
            } else {
              // Used STUN (srflx) - NAT traversal succeeded
              if (browserNatType) {
                browserNatType.textContent = '‚úì NAT allows P2P (Full Cone / Port-Restricted)';
                browserNatType.style.color = '#10b981';
              }
              if (pythonNatType) {
                pythonNatType.textContent = '‚úì NAT allows P2P (Full Cone / Port-Restricted)';
                pythonNatType.style.color = '#10b981';
              }
              if (browserNatIcon) browserNatIcon.textContent = '‚úÖ';
              if (pythonNatIcon) pythonNatIcon.textContent = '‚úÖ';
            }
            
            // Re-run analysis to update diagnosis
            await analyzeNetworkMatch();
          }
        } else {
          addLog('WEB ‚Üî PYTHON', 'ICE connection established!', 'tag-join');
          activateArrow('ice-connect');
          
          // Update analysis even without detailed stats
          await analyzeNetworkMatch();
        }
      } else if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
        // Connection failed - update browser NAT only (server NAT already detected)
        const browserNatType = document.getElementById('browser-nat-type');
        const browserNatIcon = document.getElementById('browser-nat-icon');
        
        if (browserNatType) {
          browserNatType.textContent = 'Connection failed - Likely Symmetric NAT or firewall blocking';
          browserNatType.style.color = '#ef4444';
        }
        if (browserNatIcon) browserNatIcon.textContent = '‚ùå';
        
        // Don't update Python NAT - it's already set from server detection
        
        await analyzeNetworkMatch();
      }
    });

    pc.addEventListener('connectionstatechange', () => {
      addLog('CONNECTION', 'State changed to: ' + pc.connectionState, 'tag-join');
    });

    // 3. Offer cre√´ren
    addLog('WEB CLIENT', 'Creating SDP offer‚Ä¶', 'tag-web');
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    // Wait for ICE gathering to complete with timeout
    // TURN servers need more time to respond
    addLog('WEB CLIENT', 'Waiting for ICE candidates to be gathered (including TURN)...', 'tag-web');
    const gatheringTimeout = 10000; // 10 second timeout for TURN
    const gatheringStart = performance.now();
    while (pc.iceGatheringState !== 'complete') {
      await new Promise(r => setTimeout(r, 50));
      if (performance.now() - gatheringStart > gatheringTimeout) {
        addLog('WEB CLIENT', `ICE gathering timeout after ${gatheringTimeout}ms, proceeding anyway...`, 'tag-web');
        break;
      }
    }

    setTimeValue('time5');
    addLog('WEB ‚Üí SIGNALING', 'Sending offer with ICE candidates to signaling server /offer‚Ä¶ (tijd 5)', 'tag-signaling');
    activateArrow('web-signaling', '5');

    // Simulate signaling server forwarding to Python
    await new Promise(r => setTimeout(r, 100));
    setTimeValue('time6');
    addLog('SIGNALING ‚Üí PYTHON', 'Signaling server forwards offer to PYTHON WEBRTC. (tijd 6)', 'tag-signaling');
    activateArrow('signaling-python', '6');

    const response = await fetch('/offer', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sdp: pc.localDescription.sdp,
        type: pc.localDescription.type
      })
    });

    // Show Python ICE gathering (happens during offer processing)
    setTimeValue('time7');
    addLog('PYTHON ‚Üí STUN', 'Python ICE gathering in background (check server console). (tijd 7)', 'tag-python');
    activateArrow('python-stun', '7');

    await new Promise(r => setTimeout(r, 100));
    setTimeValue('time8');
    addLog('STUN ‚Üí PYTHON', 'STUN sends candidates back to Python. (tijd 8)', 'tag-stun');
    activateArrow('stun-python', '8');

    // Python TURN request (if configured)
    await new Promise(r => setTimeout(r, 100));
    setTimeValue('time9');
    addLog('PYTHON ‚Üí TURN', 'Python requests TURN relay allocation. (tijd 9)', 'tag-python');
    activateArrow('python-turn', '9');

    await new Promise(r => setTimeout(r, 100));
    setTimeValue('time10');
    addLog('TURN ‚Üí PYTHON', 'TURN relay allocation (may timeout if unavailable). (tijd 10)', 'tag-stun');
    activateArrow('turn-python', '10');

    const answer = await response.json();
    
    // Display server NAT info if available
    if (answer.nat_info) {
      const pythonNatType = document.getElementById('python-nat-type');
      const pythonLocalIp = document.getElementById('python-local-ip');
      const pythonPublicIp = document.getElementById('python-public-ip');
      const pythonNatIcon = document.getElementById('python-nat-icon');
      
      if (pythonNatType) {
        pythonNatType.textContent = answer.nat_info.nat_type;
        pythonNatType.style.color = answer.nat_info.nat_category === 'none' ? '#10b981' : 
                                     answer.nat_info.nat_category === 'error' ? '#ef4444' : '#f59e0b';
      }
      if (pythonLocalIp && answer.nat_info.local_ip) {
        pythonLocalIp.textContent = 'Local: ' + answer.nat_info.local_ip;
      }
      if (pythonPublicIp && answer.nat_info.public_ip) {
        pythonPublicIp.textContent = 'Public: ' + answer.nat_info.public_ip;
      }
      if (pythonNatIcon) {
        pythonNatIcon.textContent = answer.nat_info.nat_category === 'none' ? '‚úÖ' : 
                                     answer.nat_info.nat_category === 'error' ? '‚ùå' : 'üõ°Ô∏è';
      }
      
      addLog('WEB CLIENT', `Server NAT: ${answer.nat_info.nat_type}`, 'tag-join');
    }
    
    setTimeValue('time11');
    addLog('PYTHON ‚Üí SIGNALING', 'Python sends answer back to signaling server. (tijd 11)', 'tag-signaling');
    activateArrow('python-signaling', '11');

    await new Promise(r => setTimeout(r, 100));
    setTimeValue('time12');
    addLog('SIGNALING ‚Üí WEB', 'Signaling server forwards answer to WEB CLIENT. (tijd 12)', 'tag-signaling');
    activateArrow('signaling-web', '12');

    await pc.setRemoteDescription(answer);

    // Extract remote candidates from SDP
    const remoteSdp = answer.sdp;
    const candidateLines = remoteSdp.split('\n').filter(line => line.startsWith('a=candidate:'));
    candidateLines.forEach(line => {
      const candidate = line.substring(2); // Remove 'a=' prefix
      remoteCandidates.push(candidate);
      
      // Update network topology with Python's IPs
      const info = parseCandidateInfo(candidate);
      if (info.type === 'host') {
        document.getElementById('python-local-ip').textContent = info.ip;
      } else if (info.type === 'srflx') {
        document.getElementById('python-public-ip').textContent = 'Public: ' + info.ip;
      }
    });

    addLog('WEB CLIENT', 'Answer applied. ICE negotiation ongoing...', 'tag-web');
    addLog('ANALYSIS', `Analyzing ${localCandidates.length} local and ${remoteCandidates.length} remote candidates...`, 'tag-join');
    
    // Don't analyze immediately - wait for connection to succeed or fail
    // Analysis will be triggered by the iceconnectionstatechange event
    
    // Start latency measurement
    startLatencyMeasurement(pc);
  }

  function startLatencyMeasurement(pc) {
    setInterval(async () => {
      try {
        const stats = await pc.getStats();
        let inboundRtp = null;
        let outboundRtp = null;
        
        stats.forEach(report => {
          if (report.type === 'inbound-rtp' && report.kind === 'video') {
            inboundRtp = report;
          }
          if (report.type === 'outbound-rtp' && report.kind === 'video') {
            outboundRtp = report;
          }
        });
        
        if (inboundRtp) {
          // Get jitter (in seconds) and convert to ms
          const jitter = inboundRtp.jitter ? (inboundRtp.jitter * 1000).toFixed(1) : 'N/A';
          
          // Estimate round-trip latency if we have timestamps
          let roundTripTime = 'N/A';
          
          // Try to get RTT from candidate-pair stats
          stats.forEach(report => {
            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
              if (report.currentRoundTripTime) {
                roundTripTime = (report.currentRoundTripTime * 1000).toFixed(0);
              }
            }
          });
          
          latencyDisplay.textContent = `RTT: ${roundTripTime}ms | Jitter: ${jitter}ms`;
        }
      } catch (e) {
        console.error('Error measuring latency:', e);
      }
    }, 500); // Update every 500ms
  }
</script>
</body>
</html>
